class RingZModN:
    def __init__(self, N):
        self.N = N

    def add(self, a, b):
        return (a + b) % self.N

    def sub(self, a, b):
        return (a - b) % self.N

    def mul(self, a, b):
        return (a * b) % self.N

    def div(self, a, b):
        # Warning: Only used when division is exact
        # We use simple modular inverse if coprime, or search if not.
        # For unit testing exact division:
        for x in range(self.N):
            if (b * x) % self.N == (a % self.N):
                return x
        raise ValueError(f"Exact division {a}/{b} impossible in Z/{self.N}")

    def gcd(self, a, b):
        """Computes the integer gcd, allowing use within ring algorithms."""
        a = abs(a)
        b = abs(b)
        while b:
            a, b = b, a % b
        return a

    def gcdex_primitive(self, a, b):
        """
        Computes extended GCD over integers to simulate
        the Gcdex operation in Z/N.
        Returns (g, s, t) such that s*a + t*b = g
        """
        r0, r1 = a, b
        s0, s1 = 1, 0
        t0, t1 = 0, 1
        
        while r1 != 0:
            q = r0 // r1
            r0, r1 = r1, r0 - q * r1
            s0, s1 = s1, s0 - q * s1
            t0, t1 = t1, t0 - q * t1
            
        return r0, s0, t0

    def gcdex(self, a, b):
        """
        Implements Gcdex(a, b)
        Returns g, s, t, u, v such that:
        [[s, t], [u, v]] * [a, b]^T = [g, 0]^T
        and sv - tu is a unit.
        """
        # We treat inputs as integers for the Euclidean step
        a_int = a % self.N
        b_int = b % self.N
        
        g, s, t = self.gcdex_primitive(a_int, b_int)

        # If b is divisible by a, s=v=1, t=0.
        # However, standard EGCD gives us s, t.
        # We need u, v to complete the unimodular matrix.
        # We choose u = -b/g, v = a/g to zero out the second row.
        
        if g == 0:
             # Case 0, 0
             return 0, 1, 0, 0, 1
             
        # Safety check for exact division (guaranteed by property of GCD)
        u = -(b_int // g)
        v = (a_int // g)
        
        # Reduce all modulo N
        return (g % self.N, s % self.N, t % self.N, u % self.N, v % self.N)
    
    def stab(self, a, b, c):
        """
        Implements Stab(a, b, c) for Z/N.
        Returns x such that gcd(a + x*b, c, N) = gcd(a, b, c, N).
        """
        # Lift to integers
        a_int = a % self.N
        b_int = b % self.N
        c_int = c % self.N
        
        # Target GCD
        # The ideal generated by (a, b, c) in Z/N corresponds to gcd(a, b, c, N) in Z
        target = self.gcd(a_int, self.gcd(b_int, self.gcd(c_int, self.N)))
        
        # Search for x. 
        # In a PID/PIR, such an x always exists.
        for x in range(self.N):
            val = a_int + x * b_int
            current_gcd = self.gcd(val, self.gcd(c_int, self.N))
            if current_gcd == target:
                return x
                
        # Should be unreachable in a PIR
        raise ValueError("Stab failed to find x")