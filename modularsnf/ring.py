"""Modular arithmetic helpers for Z/NZ used across Smith normal form.

Provides the ``RingZModN`` abstraction with arithmetic, ideal, and gcd tools
needed by the Smith normal form algorithms implemented in this package.
"""

import math

class RingZModN:
    """
    Represents Z/NZ. Implements ALL basic operations defined in 
    Storjohann's Dissertation Section 1.1.
    """
    def __init__(self, N):
        if N < 2: raise ValueError("Modulus N must be >= 2")
        self.N = N

    def add(self, a, b): return (a + b) % self.N
    def sub(self, a, b): return (a - b) % self.N
    def mul(self, a, b): return (a * b) % self.N
    def is_zero(self, a): return (a % self.N) == 0

    def gcd(self, a, b):
        """Principal generator of the ideal (a, b) in Z/NZ."""
        return math.gcd(a % self.N,
                        math.gcd(b % self.N, self.N))

    def rem(self, a, b):
        """
        Return the prescribed residue of a with respect to Ass(b).
        In Z, this is typically a % b, but we must respect the ring structure.
        Ref: Def 1.4 consistent with Z.
        """
        b_ass = self.ass(b)
        if b_ass == 0: return a % self.N
        return (a % self.N) % b_ass

    def quo(self, a, b):
        """
        Return q such that a - qb = rem(a, b).
        """
        r = self.rem(a, b)
        diff = self.sub(a, r)
        # We need q such that q*b = diff. 
        # Since diff is a multiple of b (by def of remainder), division is exact.
        return self.div(diff, b)

    def ann(self, a):
        """
        Return generator of the annihilator ideal {x | xa = 0}.
        In Z/N, Ann(a) is generated by N / gcd(a, N).
        """
        g = math.gcd(a % self.N, self.N)
        return (self.N // g) % self.N

    def gcdex(self, a, b):
        """
        Returns (g, s, t, u, v) such that:
        [s t] [a] = [g]
        [u v] [b]   [0]
        and sv - tu = unit.
        """
        a_val = a % self.N
        b_val = b % self.N

        # Dissertation constraint: if b is divisible by a, return specific form.
        # We check if b is a multiple of a in Z/N.
        if a_val != 0 and (b_val % math.gcd(a_val, self.N) == 0):
             # Check if exact division exists
             try:
                 q = self.div(b_val, a_val)
                 # s=1, t=0, u=-q, v=1 -> det = 1
                 return (a_val, 1, 0, (self.N - q) % self.N, 1)
             except ValueError:
                 pass # Fall through to standard logic if exact div fails

        # Standard Euclidean
        r0, r1 = a_val, b_val
        s0, s1 = 1, 0
        t0, t1 = 0, 1
        
        while r1 != 0:
            q = r0 // r1
            r0, r1 = r1, r0 - q * r1
            s0, s1 = s1, s0 - q * s1
            t0, t1 = t1, t0 - q * t1
            
        g, s, t = r0, s0, t0
        
        # We need u, v such that u*a + v*b = 0 and det is unit.
        # u = -b/g, v = a/g
        if g == 0: return 0, 1, 0, 0, 1
        
        u = -(b_val // g)
        v = (a_val // g)
        
        return (g % self.N, s % self.N, t % self.N, u % self.N, v % self.N)

    def div(self, a, b):
        """Exact division a/b. Raises error if b does not divide a."""
        a_val, b_val = a % self.N, b % self.N
        g, x, _ = self._egcd(b_val, self.N)
        if a_val % g != 0:
            raise ValueError(f"{a} not divisible by {b} in Z/{self.N}")
        return (x * (a_val // g)) % (self.N // g)

    def stab(self, a, b, c):
        a, b, c = a % self.N, b % self.N, c % self.N
        target = self.gcd(a, self.gcd(b, c))
        for x in range(self.N):
            candidate = (a + x * b) % self.N
            current = self.gcd(candidate, c)  # = gcd(a + x b, c, N)
            if current == target:
                return x
        raise ValueError(f"Stab failed for a={a}, b={b}, c={c} in Z/{self.N}")


    def ass(self, a):
        """Associate: gcd(a, N)."""
        return math.gcd(a % self.N, self.N)

    def unit(self, a):
        """Return u such that u*a = Ass(a)."""
        a_val = a % self.N
        g, u, _ = self._egcd(a_val, self.N)
        return u % self.N

    def _egcd(self, a, b):
        r0, r1, s0, s1 = a, b, 1, 0
        while r1:
            q = r0 // r1
            r0, r1 = r1, r0 - q*r1
            s0, s1 = s1, s0 - q*s1
        return r0, s0, 0 # t not needed here