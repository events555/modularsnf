import math
import pytest
from modularsnf.ring import RingZModN

RINGS_TO_TEST = [2, 5, 9, 12]

@pytest.mark.parametrize("N", RINGS_TO_TEST)
class TestRing:
    
    @pytest.fixture
    def ring(self, N):
        return RingZModN(N)

    def test_additive_properties(self, ring, N):
        """Verify (a + b) mod N for ALL pairs."""
        for a in range(N):
            for b in range(N):
                res = ring.add(a, b)
                assert res == (a + b) % N
                assert ring.sub(res, b) == a

    def test_multiplicative_properties(self, ring, N):
        """Verify (a * b) mod N for ALL pairs."""
        for a in range(N):
            for b in range(N):
                assert ring.mul(a, b) == (a * b) % N

    def test_gcdex_properties(self, ring, N):
        """
        For ALL pairs (a,b), verify Gcdex output satisfies:
        1. [s t; u v][a; b] = [g; 0]
        2. det(M) is a unit
        """
        for a in range(N):
            for b in range(N):
                g, s, t, u, v = ring.gcdex(a, b)
                
                # Check 1: Matrix action
                row1 = ring.add(ring.mul(s, a), ring.mul(t, b))
                row2 = ring.add(ring.mul(u, a), ring.mul(v, b))
                assert row1 == g
                assert row2 == 0
                
                # Check 2: Unimodular
                det = ring.sub(ring.mul(s, v), ring.mul(t, u))
                assert ring.gcd(det, N) == 1

    def test_annihilator(self, ring, N):
        """Verify Ann(a) * a = 0 for ALL a."""
        for a in range(N):
            x = ring.ann(a)
            assert ring.mul(a, x) == 0

    def test_division_exactness(self, ring, N):
        """
        For ALL pairs (a,b), if b|a, verify div(a,b) works.
        """
        for b in range(N):
            for k in range(N):
                a = (b * k) % N
                # If b|a is mathematically true in the ring
                # (represented by being in the ideal generated by b)
                # Note: Our div checks if a is in ideal(b), i.e., gcd(b,N)|a
                if a % math.gcd(b, N) == 0:
                    q = ring.div(a, b)
                    # Verify q*b = a
                    assert ring.mul(q, b) == a

    def test_stabilizer(self, ring, N):
        """
        For ALL triplets (a,b,c), verify Stab returns x such that
        gcd(a+xb, c) = gcd(a, b, c).
        """
        # This is O(N^3), safe for N=12 (1728 iterations)
        for a in range(N):
            for b in range(N):
                for c in range(N):
                    x = ring.stab(a, b, c)
                    lhs = ring.gcd(a + x*b, c)
                    rhs = ring.gcd(a, ring.gcd(b, c))
                    
                    # Note: gcd(a,b,c) in ring is gcd(a, gcd(b, gcd(c, N)))
                    # But since ring.gcd includes N implicitly, we compare outputs
                    assert lhs == rhs

    def test_rem_quo_consistency(self, ring, N):
        """Verify a = q*b + r for ALL pairs."""
        for a in range(N):
            for b in range(N):
                r = ring.rem(a, b)
                q = ring.quo(a, b)
                
                # Check consistency: a = q*b + r
                rhs = ring.add(ring.mul(q, b), r)
                assert a == rhs